Project 02 – Scripting in Bash
Samuel Myers: glo455
IS 2043 Fall 2020
October 1st, 2020
Introduction
	This lab was meant to allow students to apply the skills they have picked up with programming to bash script. We were to practice bash scripting by using the Git-Bash terminal we used in the first project for this class, as well as using text editor nano. We were given a guide meant as a tutorial for bash scripting to use and work through as we demonstrated our abilities to work with bash scripting and while applying what we have learned in the past about coding in general. While doing this, we were to also document our work, push our changes onto a repository created on GitHub, where we were to then share our scripts with someone else, and finally we were to submit our repository link from GitHub. 
Process
	It took me a while to figure out how I should start this assignment. I had heard that using a Linux virtual machine would be easier to follow along with for the purpose of this lab. I set one up and everything, but I came into some issues regarding GitHub. I decided to just stick it out with the Git Bash terminal we installed from the last project and work from there. Once I was situated, I used my memory from project one to create a new repository and link it from the GitHub website to the work I was doing on my terminal. When my environment was properly set up, I began my work on the steps outlined by the bash scripting guide. The first step was easy, as it just had us test out some of the features of the shell, features we were already familiar with, like “ls”, “date”, “pwd” and “cal”. The guide moved on to scripting, in which we created a document, “task.sh”, and wrote out commands in it so that by executing the task.sh document, we could run the commands from above all at once, rather than running them separately. Scripting makes it easy to automate processes like this. Unfortunately, the “cal” command does not work in the git bash terminal I was working in, and while I was looking for the right command to accomplish the same thing, I couldn’t find a fix for this. Following the scripting tutorial, we were then introduced to how bash works. We did this by opening up our task.sh file, and writing in “#!/bin/bash”. This is to define the shell interpreter that you want to use to interpret any script. While ours did it automatically, without defining the shell interpreter, it is a good practice to do so. We then moved on to file names and permissions. To start this step, I first began by creating a file named “hello-world.sh”, and then using the command “file hello-world.sh”, which would give me the information of the file, such as if it is a “Bourne-Again shell script” or if it has ASCII text. Next, I copied the "hello-world.sh" file to a new file, which i named "0_xvz". I modified the text using the nano editor to remove the "#!/bin/bash" line from the file, and again used the command "file" on the newly created file. This time, It only showed "ASCII text", rather than displaying the shell or any other information besides text. The next step involved Script Execution. This step involved using the echo command to write the text "date" to a file also named date.sh, and then making it so that the file could run. Originally, the file should not be able to run with just the command "./date.sh". I believe mine worked just fine using the git bash terminal, but i followed along anyway. I used the nano editor to write in the shebang (#!/bin/bash). Then, I used the "chmod +x" command to make the file executable. Doing these steps would help to make a file execute in a linux terminal. By completing these steps, the date.sh file would execute and show the current date. Next, we moved on to work with Relative and Absolute Paths. This was a very simple step that involved navigating through the terminal using the cd commands and either absolute paths that would take us to a certain directory, or relative paths which would take us to another nearby part instead of typing the entire absolute path again. Moving on to the next step, I deleted my old "hello-world.sh" file and made a new version of it with a shebang. It also had the command "echo "Hello World" in it, as a normal hello world file would. Then, using the chmod command again to make the file executable, I ran the file. The first time i did it, I had an issue running it. It turns out that I had messed up and wrote "hello-world,sh" instead. I quickly rectified the issue and it ran smoothly. The next step involved making a backup file, named "backup.sh", adding the shebang and then adding a tar command to create a tar ball with the home directory saved. I then used the tar command in the terminal. I made sure to change the address from what the tutorial put so that it would work on my computer as well. I ran it too to make sure it worked. Thus, I made a simple backup file, which will be built upon heavily as the guide goes on. The next step had us working with variables, and we were to create a script called welcome.sh with variables such as "greeting", "user", and "day". The former was set as "Welcome", while the latter two were set as variables which depended on who the user was and what the day was. Then, the script would output a welcome message that would welcome the user by name, and proceed to tell the user the date and their bash shell version. I ran the script and was met with my own username and the correct date, so I knew the script had worked just as planned. I also practiced assigning variables with certain values from the terminal, and using simple code to have two variables add up, subtract, etc. After familiarizing myself with how variables worked in bash, I added some variables to my backup script. I added a user variable, as well as an input and output variable, to conduct the backup. The tar command was simplified using the input and output variables, where the input variable represented the first half of the old tar command, and the output represented the second half. I also had an echo command put in, which would tell the user that the backup was done and would print out the details of the backup file. Luckily, I ran into no issue running this command. The next step went more into input and output. We practiced with how input and output can have different responses depending on certain factors, like a text file not existing. We also were introduced to standard error and standard output, the former which occurs when an error happens from an inputted command, and the latter which occurs when a command is successfully carried out. We also were introduced to redirection notation, and we practiced using this redirection notation using some text files we created. With this knowledge, I continued to add to my backup script. This time, I added the redirection notation "2>" to redirect the standard error that would occur every time the file was executed regarding the tar command to a data sink. That way, the standard error message for the tar command would not show anymore. Moving on to the next topic regarding functions, we created a file titled "function.sh", and from there added some sort of function class named "user_details", which would print the user's name and home directory to the screen. I also added a call for the function so that it would make sure to execute the script when the proper command was executed. With this knowledge, I added two functions to my backup script, one named "total_files", which was responsible for reporting the total amount of files in a directory, and one named "total_directories", which was responsible for a similar function as the former, except with directories. I also added two echo statements that would show the amount of files and directories that would be included in the backup. I was able to execute the script this time again, but it took a long while to execute, and it did not show the number of files and directories I had. In addition, some of the messages came up saying it had failed because it did not have permission to the files it was looking over. t worked for the most part besides those two hiccups, and despite looking for fixes, I could not find any that worked for what I needed to accomplish with this git bash script. Moving on to the next step, we just practiced using string comparisons (such as < and >), as well as using numeric comparisons (such as -lt and -gt). When we got familiar with how they worked, we created a text file named "comparison.sh", which we used to write a string and a number comparison. For the string comparison, we had one string assigned to "UNIX" and one assigned to "GNU". Then we wrote code to see if they were equal, and then return a boolean value based on whether or not it was equal. We did the same thing for the number comparison, except with the number variables both being set to 100. When the script was run, a 1 was outputted to the screen for the string comparison, indicating it was false that they were equal, and a 0 was outputted to the string for the number comparison, indicating that it was true that it was equal. The next step got into conditional statements. For this step, I created a file named "if_else.sh", and as the name of the file suggests, I wrote an if statement that basically took two number variables, and if the first one was less than the second one, would print a message to the terminal saying so. Without adding the else statement just yet, I tested it with different numbers to see if it worked properly. After checking, I then added my else statement to the file, which said that the first number was greater than the second number. I tested it out with different numbers to see the results. I was then tasked with adding more to my backup file, this time adding two more functions for the archived files and directories. For this step, I removed the "-type f" from the "total_files" function, so that I could account for symbolic links, as instructed in the lab guidelines. I also added an if-else statement to the backup file, so if the total files equaled the archived files, the backup would complete itself, otherwise it would fail. Moving on to the next step, Positional Parameters, I was tasked with creating a file, "param.sh", which would echo some variables. Then, I executed the program, followed by a few numbers. The script would then output the numbers based on the script positional parameters. With this knowledge, I nano edited the backup script yet again, to include an if-else if statement that would check the value of "$1". If it didn't have value, the "$user" variable would be set to the actual user, otherwise it would be assigned to the positional parameter "$1". My script had a bit of trouble running this time. I fiddled with the file addresses a bit, and while I did encounter a few more issues, I was at least able to run it this time. The next few steps revolved around bash loops. The first was the For Loop. This step had us practicing writing some basic for loops by just typing in the code for for loops in the command lines. We also created a text document to further practice for loops and calling text documents in to test them. The next step, While Loop, had us creating a "while.sh" file, where we wrote a while loop that would run the loop depending on what the counter number was. We also altered the value of the counter to test different results. The very last step, Until Loop, had us create yet another script, "until.sh", which worked similar to the while loop, except it was an until loop. Depending on the counter value, the loop would run until the condition was met. We again tested the script with different counter values. With this final knowledge, we made our last edit to the backup file. The first major change was making the backup function, which included most of the script. There was also some additional changes for the sake of readability for the user, and at the very end of the script, a for loop to run the backup function for each user directory that is given as an argument. The final product looks much more complicated than what we started with, but also gives much more information, and its functionality as a script works better than it did before. With these steps completed, so too is the lab work. My GitHub link was shared to my partner, Jaxson Fisher, at 6:35 pm on October 4th, 2020. 
Conclusion
	The goal of this lab was to get us more comfortable with creating scripts in bash and using GitHub. We did this by following a scripting guide for scripting in bash, and using our git bash terminal to code these scripts, and push them to GitHub. Scripting and using bash are very important tools for security professionals, especially Systems Administrators, who will have to work with terminals on a daily basis. Being able to write scripts and execute them will make it easy to conduct routine maintenance or daily processes. Scripts can also be written and executed to conduct security checks, so that security professionals can ensure that there is no suspicious activity happening. Therefore, learning about scripting using bash is not only important, but necessary, for security professionals. 
	This lab was very effective in its goal. I became more comfortable with using bash. I was already pretty comfortable using Linux and bash, but this lab helped strengthen my skills with it. It was also helpful to apply what we had learned about git and GitHub, and to put that knowledge to use. I feel that I have enough experience with GitHub to be comfortable using it in the future, academically or professionally. 
	The biggest difficulty spike with this lab was definitely the fact that, in order to get the scripts to work properly, I had to change a lot of the directory or folder names. While just about every command worked from the guide to my own bash terminal, the directory and folder names were definitely not the same, and part of the challenge was finding out how to apply it to my own system. Besides that, I didn't think this lab was super hard. Rather, it was a very fun lab to complete. It was nice to apply our knowledge and learn more about something relevant to our fields of work. This lab was informative, relevant, and not too difficult, and the only thing I would have liked to explore more would be maybe the use of arrays (if there are any in bash), and how to apply other more advanced coding techniques to bash. Besides that, the lab was not too difficult, and very relevant to our career aspirations. 
References
	Rendek, L. (2020, May 27). Bash Scripting Tutorial for Beginners. Retrieved October 02, 2020, from https://linuxconfig.org/bash-scripting-tutorial-for-beginners
Collaboration
	I collaborated with my partner Jaxson Fisher, by sharing my GitHub link with him. I also referred to Slack for some help with the assignment, and asked a question regarding the submission, which professor Rita Mitra answered for me. 
	
Code Review (Jaxson Fisher)
This project looks pretty good, the lab instructions were followed to a T with the exception of pathing file differences similar to mine as our computers have different directory layouts. I don't believe there are any prominent errors in the code, everything seems to be in line with the lab details so I don't have any suggestions for alterations in the code given what surface level knowledge I now have of shellscript. I believe the code is indented properly as it's near identical to the instructions and everything ran fine when I tested it in the bash compiler.
